* 外观模式 外观模式的一般描述是：外观模式定义了一个高层的功能，为子系统中的多个模块协同的完成某种功能需求提供简单的对外功能调用方式，使得这一子系统更加容易被外部使用。

1.一个系统拆分成多子系统
2.外部不直接访问子系统
3.一个操作由多个子系统完成, 外观模式提供一个接口，封装子系统的操作

外观模式的目的不是给予子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单地使用子系统。

总结:对外提供一个好看的接口。不需要关心内部实现

例 : (由外观例子, 类似例子)
```javeScript
class User {
	hp:number;
	run() {
		consolo.log('run');
	}
}

// 强势假设hp >100才能run
let user = new User();
if (hp > 100) {
	user.run();
}
```
==> 改为

```javeScript
class User {
	hp:number;
	run() {
		if (hp > 100) {
			consolo.log('run');
		}
	}
}

let user = new User();
user.run();
```
两者的区别
例1, 外部判断了run的条件, 访问了内部hp, 即内部的逻辑和成员都使用了, 这对使用者来说, 不友好
例2, 外部直接调用run , run内部装逻辑和操作都封装了, 对外界来说, 是友好的


