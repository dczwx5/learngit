using UnityEngine;
using System.Collections;

public class _Sampling : MonoBehaviour {

	// Use this for initialization
	void Start () {
        /**
        Aliasing(走样)
            1.几何体走样（几何物体的边缘有锯齿），几何走样由于对几何边缘采样不足导致。
            2.着色走样，由于对着色器中着色公式（渲染方程）采样不足导致。比较明显的现象就是高光闪烁。
            3.时间走样，主要是对高速运动的物体采样不足导致。比如游戏中播放的动画发生跳变等。 
         \*/
        /**
        SSAA（超采样反走样）
            从名字可以看出，超采样技术就是以一个更大的分辨率来渲染场景，然后再把相邻像素值做一个过滤（比如平均等）得到最终的图像（Resolve）。
            因为这个技术提高了采样率，所以它对于解决上面几何走样和着色走样都是有效果的。
            虽然SSAA可以有效的解决几何走样和着色走样问题，但是它需要更多的显存空间以及更多的着色计算（每个子采样点都需要进行光照计算），所以一般不会使用这种技术。
            顺着上面的思路，如果我们对最终的每个像素着色，而不是每个子采样点着色的话，那这样虽然显存还是那么多，但是着色的数量少了，那它的效率也会有比较大的提高。这就是我们今天想要主要说的MSAA技术。
    
            0.提高了采样率
            1.以一个更大的分辨率来渲染场景
            2.在像素着色器进行
            3.需要更多的显存空间以及更多的着色计算，所以一般不会使用这种技术
        */
        /**
            MSAA
            在前面提到的SSAA中，每个子采样点都要进行单独的着色，这样在片断（像素）着色器比较复杂的情况下还是很费的。
            那么能不能只计算每个像素的颜色，而对于那些子采样点只计算一个覆盖信息（coverage）和遮挡信息（occlusion）来把像素的颜色信息写到每个子采样点里面呢？
            最终根据子采样点里面的颜色值来通过某个重建过滤器来降采样生成目标图像。这就是MSAA的原理。注意这里有一个很重要的点，就是每个子像素都有自己的颜色、深度模板信息
            ，并且每一个子采样点都是需要经过深度和模板测试才能决定最终是不是把像素的颜色得到到这个子采样点所在的位置，而不是简单的作一个覆盖测试就写入颜色。
            关于这个的出处，我在接下来的文章里会写出多个出处来佐证这一点。现在让我们先把MSAA的原理讲清楚。 

            0.提高采样率
            1.比SSAA好
            2.在最后的像素处理
            3.
           */
    }

    // Update is called once per frame
    void Update () {

}
}
