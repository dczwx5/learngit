---
title: 内存
grammar_cjkRuby: true
---


[TOC]
## 堆
* 二叉堆, 二叉树结构, 排序的树形数据结构
* 分配动态创建空间(new)
* 向上增长, 处于较高的地址
* 程序自行申请空间
* 只要不释放空间，就一直可以访问到
* 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆
* 找到结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。  
  也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。
* 由new分配的内存，一般速度比较慢，而且容易产生内存碎片
* 一般是在堆的头部用一个字节存放堆的大小
* 堆在编译时就确定?, 存取速度相对栈慢
## 栈
* 分配局部变量空间
* 向下增长
* 系统自动分配空间
* 自动分配自动回收，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉
* 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出
* 申请速度快
* 栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
* 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。  
  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。  
``` actionscript
public function test(a:int, b:int) : void {
	var c:int;
	var d:int;
}
// 调用test, trace(a+b)语句的地址入栈
// 参数2(b)入栈, 参数1(a)入栈
// test 函数中, 局部变量c入栈, 局部变量d入栈
test(1, 2); 
// test调用完毕, test的d出栈, c出栈, 参数1(a)出栈, 参数2(b)出栈
// trace(a+b)语句的地址出栈, 栈顶指针指向trace(a+b)语句的地址, 程序继续运行
trace(100);
```
* 栈是在运行时赋值? 存取速度比堆快
## 静态区
* 分配静态变量
* 分配全局变量
## 只读区
* 分配常量
* 分配代码空间
