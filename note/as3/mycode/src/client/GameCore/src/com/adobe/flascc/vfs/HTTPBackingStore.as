// Copyright (c) 2013 Adobe Systems Inc

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package com.adobe.flascc.vfs {

import flash.events.AsyncErrorEvent;
import flash.events.Event;
import flash.events.IOErrorEvent;
import flash.events.ProgressEvent;
import flash.events.SecurityErrorEvent;
import flash.net.URLLoader;
import flash.net.URLLoaderDataFormat;
import flash.net.URLRequest;
import flash.utils.ByteArray;
import flash.utils.Endian;

/**
 * A BackingStore that uses a URLLoader to load its files. This requires a manifest.as file to be
 * generated by the "genfs" tool in the flascc SDK. After being constructed, an instance of this
 * BackingStore will start downloading the files from the manifest. You can listen to the <code>progress</code>,
 * <code>complete</code> and <code>ioerror</code> events to monitor download progress.
 *
 * <p>After a download has completed it is added to the VFS and is available for use.</p>
 */
[Ignore]
[Deprecated]
public class HTTPBackingStore extends InMemoryBackingStore {
    // The genfs program generates an as file that
    // defines some of the data needed by this script
    // include 'manifest.as';

	private static var vfsFiles:Array = [];
	private static var vfsTotalSize:uint = 0;

	private static function initDirs():void {
		// NOOP
	}

    private var bytesLoaded:uint;
    //noinspection JSUnusedLocalSymbols
    private var percentComplete:uint;
    private var currentLoader:URLLoader;
    private var currentVPath:String;
    private var currentUrls:Array = [];
    private var currentContents:ByteArray;

    public function HTTPBackingStore() {
        initDirs();
        startNewFile();
    }

    private function startNewFile():void {
        if (currentVPath == null) {
            var newfile:Array = vfsFiles.shift();
            if (newfile == null) {
                // All files finished
                this.dispatchEvent(new Event(Event.COMPLETE));
                return;
            }

            currentVPath = newfile[0];
            currentContents = new ByteArray();
            currentContents.endian = Endian.LITTLE_ENDIAN;
            currentContents.length = newfile[1];
            currentContents.position = 0;
            currentUrls.length = 0;
            for (var i:int = 2; i < newfile.length; i++)
                currentUrls.push(newfile[i]);
        }

        startNewDownload();
    }

    private function startNewDownload():void {
        var url:String = currentUrls.shift();
        if (url == null) {
            // we're done with this file, put it in the VFS
            //currentContents.uncompress()
            addFile(currentVPath, currentContents);

            // start a new file download
            currentVPath = null;
            startNewFile();
            return;
        }

        currentLoader = new URLLoader(new URLRequest(url));
        currentLoader.dataFormat = URLLoaderDataFormat.BINARY;
        currentLoader.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onError);
        currentLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onError);
        currentLoader.addEventListener(IOErrorEvent.IO_ERROR, onError);
        currentLoader.addEventListener(Event.COMPLETE, onComplete);
        currentLoader.addEventListener(ProgressEvent.PROGRESS, onProgress);
    }

    private function onComplete(e:Event):void {
        bytesLoaded += currentLoader.data.length;
        currentContents.writeBytes(currentLoader.data);

        var pe:ProgressEvent = new ProgressEvent(ProgressEvent.PROGRESS);
        pe.bytesLoaded = bytesLoaded;
        pe.bytesTotal = vfsTotalSize;
        this.dispatchEvent(pe);

        startNewDownload();
    }

    private function onError(e:Event):void {
        this.dispatchEvent(e);
    }

    private function onProgress(e:Event):void {
        var pe:ProgressEvent = new ProgressEvent(ProgressEvent.PROGRESS);
        pe.bytesLoaded = bytesLoaded + e.target.bytesLoaded;
        pe.bytesTotal = vfsTotalSize;
        this.dispatchEvent(pe);
    }
}
}
